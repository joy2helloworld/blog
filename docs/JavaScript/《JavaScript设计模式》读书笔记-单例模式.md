[issue](https://github.com/hoperyy/blog/issues/14)

#	基础知识回顾

+	`this` 的指向
	+	根据函数的指针是谁的属性
		+	直接属性
		+	间接属性（实例）
		+	`window`
	+	`apply/call`

+	`this` 的指向是根据函数运行的方式变化的，不是一定的
+	作用域链
	
	活动对象 -- 函数定义处的环境 ...

+	谁能访问活动对象中的变量？
	
	+	定义在其中的函数

+	几种对象区分

	+	函数对象
	+	活动对象

		函数执行时创建，执行完毕后销毁；

		但如果活动对象里有对象被外部引用，则不会销毁。
 
+	对象何时销毁：没有指针指向它的时候

+	一个闭包包含
	+	函数对象
	+	函数对象的作用域链

+	每个函数都有自己的作用域链

#	第四章内容


+	用构造函数的属性存储实例

+	或者用活动对象存储实例

	+	创建一个活动对象(存储实例)

	+	创建一个/多个函数对象，多次执行

+	示例1
	
	```
	var GetInstance = (function() {
		var instance;

		return function(html) {
			if(instance) {
				instance = 给实例赋值;
			}

			实例处理代码

			return instance;
		}
	})();
	```

	效果就是 `new` 了两次，但是获得了同一个实例。

+	示例2：改进

	引入代理类

	上述代码的缺点就是违背了单一职责原则，改进如下，将实例处理代码封装到`Handler`里

	```
	var GetInstance = (function() {
		var instance;

		return function() {
			if(instance) {
				instance = new Handler();
			}

			return instance;
		}
	})();
	```

	至于使用

	```
	var a = new GetInstance();
	var a = new GetInstance();
	```

	两个 `new` 并没有实际作用（因为没有用到`this`），更多的是象征的意义。

	而 `new Handler()` 其实也不是必须的。

+	单例模式的核心：**确保只有一个示例，并提供全局访问**
	
	在 `JS` 中，实现很简单。用全局变量即可实现，如 `var a = {}`;

	但为了减少全局变量污染，可以通过以下途径减少污染

	1、使用命名空间

	2、把变量封装到闭包内部，开放接口与外界通信，如定义在闭包里的函数。

+	通用的惰性单例

	这个例子里包含三个对象：原始函数、中间函数、闭包的活动对象

	要搞清楚的几个问题。从原始函数出发思考。

	原始函数多次执行会产生多个实例，因此需要一个中间函数，多次执行中间函数只执行一次原始函数，且能存储实例。

	对中间函数的要求：

	1、执行时能够执行原始函数

	2、能够让原始函数的执行环境和中间函数保持一致，即需要 `apply(this, arguments)`

	3、能存储实例

	+	可以通过闭包
	+	可以通过其他方式存储